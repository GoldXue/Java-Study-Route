# 1 字符串出现次数的TopK问题（字符串）

```java
public String[][] topKstrings (String[] strings, int k) {
        // write code here
        if(k==0)return new String[][]{};
        String[][] res = new String[k][2];
        TreeMap<String,Integer> map = new TreeMap();
        for(int i=0;i<strings.length;i++){
            String cur = strings[i];
            if(map.containsKey(cur)){
                map.put(cur,map.get(cur)+1);
            }else{
                map.put(cur,1);
            }
        }
        ArrayList<Map.Entry<String,Integer>> list = new ArrayList(map.entrySet());
    //判决：如果o1的value等于o2的value，那么比较o1和o2哪个key的字符集小，反之比较o1和o2哪个value大。
        Collections.sort(list,
                        (o1,o2)->o1.getValue().compareTo(o2.getValue())==0?o1.getKey().compareTo(o2.getKey()):o2.getValue().compareTo(o1.getValue()));
        for(int i=0;i<k;i++){
            res[i][0] = list.get(i).getKey();
            res[i][1] = String.valueOf(list.get(i).getValue());
        }
        return res;
    }
```

# 2 矩阵最小路径和（数组）

构造一个数组存放当前结点最小的路径和

```java
public int minPathSum (int[][] matrix) {
        // write code here
        int x = matrix.length;int y = matrix[0].length;
        for(int i=0;i<x;i++){
            for(int j=0;j<y;j++){
                if(i==0&&j==0)continue;
                if(i==0){matrix[0][j] += matrix[0][j-1];}
                else if(j==0){
                    matrix[i][0]+=matrix[i-1][0];
                }
                else{
                    matrix[i][j] += Math.min(matrix[i-1][j],matrix[i][j-1]);
                }
            }
        }
        return matrix[x-1][y-1];
    }
}
```

# 3 *kmp算法（字符串）

给你一个文本串 T ，一个非空模板串 S ，问 T 在 S 中出现了多少次

```
输入："ababab","abababab"

输出：2
```



- 确定next数组：主要是根据之前是否有重复前缀字串来确定应该跳到什么位置，首先索引0位置，没有信息可以参考，直接回退到0；索引1位置，a和b不相等，没有重复前缀字串，直接回退到0；索引2位置，这时候有公共前缀a，回退到前缀的下一个索引1；索引3位置，这时候有公共前缀ab，回退到前缀的下一个索引2；索引4位置，这时候有公共前缀aba，回退到前缀的下一个索引3；索引5位置，这时候有公共前缀abab，回退到前缀的下一个索引4（上面所说的公共前缀尽可能取最长的）。

```java
	public int kmp (String S, String T) {
        // write code here
        int[] next = getNext(S);
        int Slen = S.length();int Tlen = T.length();
        int res = 0;
        for(int i=0,j=0;i<Tlen;i++){
            while(j>0&&T.charAt(i)!=S.charAt(j)){
                j = next[j-1];
            }
            if(T.charAt(i)==S.charAt(j))j++;
            if(j==Slen){
                res++;
                j = next[j-1];
            }
        }
        return res;
    }
//确定next数组，找出重复前缀
    private int[] getNext(String S){
        int[] next = new int[S.length()];
        for(int i=1,j=0;i<S.length();i++){
            while(j>0&&S.charAt(i)!=S.charAt(j)){
                j = next[j-1];
            }
            if(S.charAt(i)==S.charAt(j))j++;
            next[i]=j;
        }
        return next;
    }
```

# 4 最长公共子序列（字符串）

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

## 4.1 返回连续的结果

```
输入："1AB2345CD","12345EF"
返回值："2345"
```

```java
public String LCS (String str1, String str2) {
    if(str1.length()==0||str2.length()==0)return "-1";
    int len1=str1.length();int len2=str2.length();
    int[][] temp = new int[len1+1][len2+1];
    int maxlen=0;int index = 0;
    for(int i=1;i<=len1;i++){
        char char1 = str1.charAt(i-1);
        for(int j=1;j<=len2;j++){
            char char2=str2.charAt(j-1);
            if(char1==char2){
                temp[i][j] = temp[i-1][j-1]+1;
                if(temp[i][j]>maxlen){
                    maxlen = temp[i][j];
                    index = i;
                }
            }
        }
    }
    return maxlen==0 ? "-1":str1.substring(index-maxlen,index);
}
```

## 4.2 非连续的返回长度

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

需要一个二维辅助数组来记录两个字符串的公共长度。

```java
public int longestCommonSubsequence(String text1, String text2) {
​    int[][] temp = new int[text1.length()+1][text2.length()+1];
​    for(int i=1;i<=text1.length();i++){
​      char cur1 = text1.charAt(i-1);
​      for(int j=1;j<=text2.length();j++){
​        char cur2 = text2.charAt(j-1);
​        if(cur1==cur2){
​          temp[i][j] = temp[i-1][j-1]+1;
​        }else{
​          temp[i][j] = Math.max(temp[i-1][j],temp[i][j-1]);
​        }
​      }
​    }
​    return temp[text1.length()][text2.length()];
  }
```

## 4.3 返回非连续的字符串结果

```
输入："1A2C3D4B56","B1D23A456A"
返回值："123456"
```

```java
 public String LCS (String s1, String s2) {
        if(s1.length()==0||s2.length()==0)return "-1";
        int len1 = s1.length();int len2 = s2.length();
        int[][] temp = new int[len1+1][len2+1];
        for(int i=1;i<=len1;i++){
            char char1 = s1.charAt(i-1);
            for(int j=1;j<=len2;j++){
                char char2 = s2.charAt(j-1);
                if(char1==char2){
                    temp[i][j]=temp[i-1][j-1]+1;
                }else{
                    temp[i][j]=Math.max(temp[i-1][j],temp[i][j-1]);
                }
            }
        }
        StringBuilder res = new StringBuilder();
        int lens1 = len1;int lens2 = len2;
        while(lens1>0&&lens2>0){
            if(s1.charAt(lens1-1)==s2.charAt(lens2-1)){
                res.append(s1.charAt(lens1-1));
                lens1--;lens2--;
            }else{
                //如果上方大于左方，往上，否则往左
                if(temp[lens1-1][lens2]>temp[lens1][lens2-1]){
                    lens1--;
                }
                else lens2--;
            }
        }
        if(res.length()==0)return "-1";
        return res.reverse().toString();
    }
```

# 5 合并区间（数组）

给出一组区间，请合并所有重叠的区间。

请保证合并后的区间按区间起点升序排列。

```
输入：[[10,30],[20,60],[80,100],[150,180]]
返回值：[[10,60],[80,100],[150,180]]
```

先按左区间进行排序，在设两个值，一个左区间一个右区间来计算。

```java
public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
    ArrayList<Interval> res = new ArrayList();
    Collections.sort(intervals,(a,b)->a.start-b.start);
    if(intervals.size()==0)return res;
    int len = intervals.size();
    int i = 0;
	while (i < len) {
        int left = intervals.get(i).start;
        int right = intervals.get(i).end;
        while (i < len-1 && intervals.get(i+1).start <= right) {
            right = Math.max(right,intervals.get(i+1).end);
            i++;
        }
        res.add(new Interval(left,right));
        i++;
    }
    return res;
}
```

# 6 链表反转（链表）

给定单链表的头节点 `head` ，请反转链表，并返回反转后的链表的头节点。

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

```java
  public ListNode reverseList(ListNode head) {

​    if(head==null||head.next==null)return head;
​    ListNode pre = null;
​    while(head!=null){
​      ListNode cur = head.next;
​      head.next = pre;
​      pre = head;
​      head = cur;
​    }
​    return pre;
  }
```

# 7 二叉树的层序遍历（二叉树）

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

```
 3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

提示：使用队列来存数据

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList();
        if(root==null)return res;
        Queue<TreeNode> que = new LinkedList();
        que.add(root);
        while(!que.isEmpty()){
            int size = que.size();
            List<Integer> list = new ArrayList();
            while(size>0){
                TreeNode cur = que.poll();
                list.add(cur.val);
                if(cur.left!=null)que.add(cur.left);
                if(cur.right!=null)que.add(cur.right);
                size--;
            }
            res.add(list);
        }
        return res;
    }
```

# 8 连续子数组的最大和（数组）

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```java
public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int max = 0;
        for(int i=0;i<nums.length;i++){
            max += nums[i];
            res = Math.max(res,max);
            if(max<0){
                max=0;
                continue;
            }
        }
        return res;
    }
```

# 9 *LRU缓存（哈希和双向链表）

设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。

```
案例：
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

# 10 *递增子序列

给你一个整数数组 nums ，找出并返回所有该数组中**不同的递增子序列**，递增子序列中**至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

```java
	List<List<Integer>> res = new ArrayList();
    List<Integer> temp = new ArrayList();
    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(0,Integer.MIN_VALUE,nums);
        return res;
    }
    public void dfs(int index,int last,int[] nums){
        if(index==nums.length){
            if(temp.size()>=2){
                res.add(new ArrayList(temp));
            }
            return ;
        }
        //当前元素大于上一个元素，则向下递归直到结束，然后每次递归删除temp中最后一个元素
        if(nums[index]>=last){
            temp.add(nums[index]);
            dfs(index+1,nums[index],nums);
            temp.remove(temp.size()-1);
        }
        //若当前元素不等于上一个元素，则继续向下递归
        if(nums[index] != last){
            dfs(index+1,last,nums);
        }
    }
```

# 11 最长不重复子串（字符串）

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```java
public int lengthOfLongestSubstring(String s) {
        HashMap<Character,Integer> map = new HashMap();
        int index1=0;
        int res = 0;
        for(int index=0;index<s.length();index++){
            char cur = s.charAt(index);
            if(map.containsKey(cur)){
                //若map中包含当前元素cur，则index1取比较大的值
                index1 = Math.max(index1,map.get(cur)+1);
            }
            map.put(cur,index);
            res = Math.max(res,index-index1+1);
        }
        return res;
    }
```

# 12 K个一组翻转链表（链表）

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211025095252953.png" alt="image-20211025095252953" style="zoom:75%;" />

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

```java
public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null||head.next==null)return head;
        //确定链表长度
        ListNode temp = head;
        int length = 0;
        while(temp!=null){
            length++;
            temp=temp.next;
        }
        ListNode now = new ListNode();
        ListNode res = now;
        for(int i=0;i<length/k;i++){
            //先翻转k个结点
            ListNode pre = null;
            for(int j=0;j<k;j++){
                ListNode curN = head.next;
                head.next = pre;
                pre = head;
                head = curN;
            }
            //now指向翻转后的头结点
            now.next = pre;
            //随后now变为尾结点
            while(now.next!=null){
                now = now.next;
            }
        }
        if(head!=null)now.next = head;
        return res.next;
    }
```

# 13 快速排序

```java
public int[] sortArray(int[] nums) {
        sort(nums,0,nums.length-1);
        return nums;
    }
    public void sort(int[] nums,int left,int right){
        if(left<right){
            int[] p = part(nums,left,right,nums[right]);
            sort(nums,left,p[0]);
            sort(nums,p[1],right);
        }
    }
    public int[] part(int[] nums,int left,int right,int target){
        int less = left-1;
        int big = right+1;
        while(left<big){
            if(nums[left]<target){
                swap(nums,left++,++less);
            }
            else if(nums[left]>target){
                swap(nums,left,--big);
            }else{
                left++;
            }
        }
        return new int[]{less,big};
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

# 14 三数之和（数组）

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

```java
public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList();
        if(nums.length==0||nums.length==1||nums.length==2){
            return res;
        }
        Arrays.sort(nums);
        for(int i=0;i<nums.length-2;i++){
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            int third = nums.length-1;
            for(int j=i+1;j<nums.length-1;j++){
                if(j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                //如果三数之和大于0且第二个数的下标小于third
                while(nums[i]+nums[j]+nums[third]>0&&j<third){
                    third--;
                }
                //如果third==j，结束循环
                if(j==third)break;
                if(nums[i]+nums[j]+nums[third]==0){
                    List<Integer> list = new ArrayList();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[third]);
                    res.add(list);
                }
            }
        }
        return res;
    }
```

# 15 两数之和（数组）

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

```java
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap();
        for(int i=0;i<nums.length;i++){
            int cur = nums[i];
            if(map.containsKey(target-cur)){
                return new int[]{map.get(target-cur),i};
            }
            map.put(cur,i);
        }
        return new int[]{-1,-1};
    }
```

# 16 环形链表，是否有环（链表）

给定一个链表，判断链表中是否有环。快慢指针

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211026101846055.png" alt="image-20211026101846055" style="zoom:67%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

```java
public boolean hasCycle(ListNode head) {
        if(head==null)return false;
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&&fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast){
                return true;
            }
        }
        return false;
    }
```

# 17 合并两个有序链表(链表)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode();
        ListNode cur = head;
        while(l1!=null&&l2!=null){
            if(l1.val<=l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        while(l1!=null){
            cur.next = l1;
            l1 = l1.next;
            cur = cur.next;
        }
        while(l2!=null){
            cur.next = l2;
            l2 = l2.next;
            cur = cur.next;
        }
        return head.next;
    }
```

# 18 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```java
public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int i=0;i<prices.length;i++){
            int cur = prices[i];
            min = Math.min(min,cur);
            max = Math.max(max,cur-min);
        }
        return max;
    }
```

# 19 相交链表（链表）

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null||headB==null)return null;
        int sizeA = sizes(headA);
        int sizeB = sizes(headB);
        ListNode lastA = last(headA);
        ListNode lastB = last(headB);
        if(lastA!=lastB)return null;
        if(sizeA>=sizeB){
            for(int i=0;i<sizeA-sizeB;i++){
                headA = headA.next;
            }
            while(headA!=headB){
                headA = headA.next;
                headB = headB.next;
            }
        }else{
            for(int i=0;i<sizeB-sizeA;i++){
                headB = headB.next;
            }
            while(headA!=headB){
                headA = headA.next;
                headB = headB.next;
            }
        }
        return headA;

    }
    public ListNode last(ListNode head){
        while(head.next!=null){
            head = head.next;
        }
        return head;
    }
    public int sizes(ListNode head){
        int i = 1;
        while(head.next!=null){
            head = head.next;
            i++;
        }
        return i;
    }
```

# 20 合并两个有序数组（数组）

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素
```

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int length = nums1.length;
        int i=m-1;int j=n-1;
        while(i>=0&&j>=0){
            nums1[--length]=nums1[i]>nums2[j]?nums1[i--]:nums2[j--];
        }
        while(i>=0){
            nums1[--length] = nums1[i--];
        }
        while(j>=0){
            nums1[--length] = nums2[j--];
        }
    }
```

# 21 二叉树的最近公共祖先(二叉树)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211027091910051.png" alt="image-20211027091910051" style="zoom:67%;" />

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        Stack<TreeNode> pathp = new Stack();
        Stack<TreeNode> pathq = new Stack();
        trace(root,p,pathp);
        trace(root,q,pathq);
        TreeNode father = root;
        while(!pathp.isEmpty()&&!pathq.isEmpty()){
            TreeNode cur1 = pathp.pop();
            TreeNode cur2 = pathq.pop();
            //若两者不相等则继续，相等的话父结点就等于它，直到栈空
            if(cur1.val!=cur2.val)continue;
            else father = cur1;
        }
        return father;
    }
    public boolean trace(TreeNode root,TreeNode target,Stack<TreeNode> path){
        if(root==null)return false;
  	  if(root.val==target.val||trace(root.left,target,path)||trace(root.right,target,path)){
            path.push(root);
            return true;
        } 
        return false;
    }
```

# 22 有效的括号（字符串）

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

栈+HashMap

```
输入：s = "()[]{}"
输出：true
输入：s = "(]"
输出：false
```

```java
public boolean isValid(String s) {
        Stack<Character> stack = new Stack();
        HashMap<Character,Character> map = new HashMap();
        map.put(')','(');map.put(']','[');map.put('}','{');
        for(int i=0;i<s.length();i++){
            char cur = s.charAt(i);
            if(map.containsKey(cur)){
                //如果出现右括号，此时若栈为空或者栈最后一个元素不等于此右括号对应的左括号则返回false
                if(stack.isEmpty()||stack.get(stack.size()-1)!=map.get(cur)){
                    return false;
                }else{
                    stack.pop();
                }
            }else{
                stack.push(cur);
            }
        }
        if(stack.isEmpty())return true;
        else return false;
    }
```

# 23 字符串相加（字符串）

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。

当不知道字符串长度时可以使用stringbuilder，与linkedlist类似

```
输入：num1 = "11", num2 = "123"
输出："134"
```

```java
public String addStrings(String num1, String num2) {
        int length1 = num1.length()-1;
        int length2 = num2.length()-1;
        int cur = 0;int next = 0;
        StringBuilder res = new StringBuilder();
        while(length1>=0&&length2>=0){
            int x = num1.charAt(length1)-'0';
            int y = num2.charAt(length2)-'0';
            cur = (x+y+next)%10;
            res.append(cur);
            next = (x+y+next)/10;
            length1--;length2--;
        }
        while(length1>=0){
            int x = num1.charAt(length1)-'0';
            cur = (x+next)%10;
            res.append(cur);
            next = (x+next)/10;
            length1--;
        }
        while(length2>=0){
            int x = num2.charAt(length2)-'0';
            cur = (x+next)%10;
            res.append(cur);
            next = (x+next)/10;
            length2--;
        }
        if(next>0)res.append(next);
        return res.reverse().toString();
    }
```

# 24 最长回文子串（字符串）

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```java
public String longestPalindrome(String s) {
        String res = "";
        for(int i=0;i<s.length();i++){
            String temp = returns(s,i,i).length()>returns(s,i,i+1).length() 
            ? returns(s,i,i):returns(s,i,i+1);
            res = temp.length()>res.length() ? temp:res;
        }
        return res;
    }
    public String returns(String s,int left,int right){
        while(left>=0&&right<s.length()){
            if(s.charAt(left)==s.charAt(right)){
                left--;right++;
                continue;
            }
            break;
        }
        return s.substring(left+1,right);
    }
```

# 25 二叉树锯齿形层序遍历（二叉树）

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

给定二叉树

```
 3
   / \
  9  20
    /  \
   15   7
```

返回结果

```
[
  [3],
  [20,9],
  [15,7]
]
```

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList();
        if(root==null)return res;
        Queue<TreeNode> que = new LinkedList();
        que.add(root);
        while(!que.isEmpty()){
            List<Integer> list = new ArrayList();
            int size = que.size();
            while(size-->0){
                TreeNode cur = que.poll();
                list.add(cur.val);
                if(cur.left!=null)que.add(cur.left);
                if(cur.right!=null)que.add(cur.right);
            }
            res.add(list);
        }
        reverse(res);
        return res;
    }
    public void reverse(List<List<Integer>> list){
        int size = list.size();
        for(int i=0;i<size;i++){
            if(i%2==1){
                List<Integer> temp = list.get(i);
                Collections.reverse(temp);
                list.set(i,temp);
            }
        }
    }
```

# 26 反转链表-Ⅱ

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表。

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

```Java
public ListNode reverseBetween(ListNode head, int left, int right) {
        if(head==null||head.next==null||left==right)return head;
        ListNode cur = head;ListNode res = null;int index = 1;
        ListNode firstH = null;
        while(index<left){
            firstH = cur;
            cur = cur.next;
            index++;
        }
        ListNode pre = null;
        ListNode secondH = cur;
        ListNode temp = null;
        while(index<=right){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
            index++;
        }
        ListNode last = temp;
        if(firstH==null){
            res = pre;
            secondH.next = last;
        }else{
            res = head;
            firstH.next = pre;
            secondH.next = last;
        }
        return res;
    }
```

# 27 岛屿数量（二维数组）

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

解法：将岛屿渲染

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

```Java
public int numIslands(char[][] grid) {
        int res = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]=='1'){
                    decorate(grid,i,j);
                    res++;
                }
            }
        }
        return res;
    }
    public void decorate(char[][] grid,int i,int j){
        //如果超过边界返回
        if(i<0||j<0||i==grid.length||j==grid[0].length)return;
        //把岛屿（等于‘1’）渲染为2.
        if(grid[i][j]=='1'){
            grid[i][j]='2';
            decorate(grid,i-1,j);
            decorate(grid,i+1,j);
            decorate(grid,i,j-1);
            decorate(grid,i,j+1);
        }
    }
```

# 28 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。

思路：如果mid大于等于第一个元素 ，那么应该判断target与num[0]和num[mid]的大小，若target大于等于num[0]小于num[mid] 则right=mid-1。若num[mid]小于第一个元素（右边有序），此时若target<=num[length-1]且target>num[mid]，在此范围内找，反之在右边。

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

```java
public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        int mid = 0;
        while(left<=right){
            mid = (left+right)/2;
            if(nums[mid] == target)return mid;
            if(nums[0]<=nums[mid]){
                if(nums[0]<=target&&target<nums[mid]){
                    right = mid-1;
                }else{
                    left = mid+1;
                }
            }else{
                if(nums[mid]<target&&target<=nums[nums.length-1]){
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }
        }
        return -1;
    }
```

# 29 *全排列（回溯算法）

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```java
List<List<Integer>> res = new ArrayList();
    List<Integer> temp = new ArrayList();
    public List<List<Integer>> permute(int[] nums) {
        for(int num:nums){
            temp.add(num);
        }
        back(0,nums.length);
        return res;
    }
    public void back(int first,int length){
        if(first==length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }
        for(int i=first;i<length;i++){
            Collections.swap(temp,first,i);
            back(first+1,length);
            Collections.swap(temp,first,i);
        }
    }
```

# 30 环形链表-Ⅱ

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

![image-20211109102154394](C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211109102154394.png)

解法：快慢指针

```java
public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null&&fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast==slow){
                fast = head;
                while(fast!=slow){
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
```

# 31 螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素.

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

```java
public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList();
        int lx = 0;int ly = 0;
        int rx = matrix[0].length-1;int ry = matrix.length-1;
        while(ly<=ry&&lx<=rx){
            if(ly==ry&&lx<rx){
                for(int i=lx;i<=rx;i++){
                    res.add(matrix[ly][i]);
                }
            }
            else if(lx==rx&&ly<ry){
                for(int i=ly;i<=ry;i++){
                    res.add(matrix[i][lx]);
                }
            }
            else{
                for(int i=lx;i<=rx;i++){
                    res.add(matrix[ly][i]);
                }
                for(int i=ly+1;i<=ry;i++){
                    res.add(matrix[i][rx]);
                }
                for(int i=rx-1;i>=lx;i--){
                    res.add(matrix[ry][i]);
                }
                for(int i=ry-1;i>ly;i--){
                    res.add(matrix[i][lx]);
                }
            }
            lx++;ly++;rx--;ry--;
        }
        return res;
    }
```

# 32 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

```java
public int search(int[] nums, int target) {
        int left=0;int right=nums.length-1;
        int mid = -1;
        while(left<=right){
            mid = (left+right)>>1;
            if(nums[mid]==target)return mid;
            if(target>nums[mid])left = mid+1;
            else right = mid-1;
        }
        return -1;
    }
```

# 33 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false.

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

```java
Stack<Integer> s1 = null;
    Stack<Integer> s2 = null;
    int peeks = 0;
    public MyQueue() {
        s1 = new Stack();
        s2 = new Stack();
    }
    
    public void push(int x) {
        if(s1.isEmpty())peeks=x;
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        s2.push(x);
        while(!s2.isEmpty()){
            s1.push(s2.pop());
        }
    }
    
    public int pop() {
        int temp = s1.pop();
        if(!s1.isEmpty())peeks = s1.peek();
        return temp;
    }
    
    public int peek() {
        return peeks;
    }
    
    public boolean empty() {
        if(s1.isEmpty())return true;
        else return false;
    }
```



# 34 合并K个排序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

思路：两个两个链表合并，然后将合并的结果存到当前指向的下一个

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

```java
public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0)return null;
        for(int i=0;i<lists.length-1;i++){
            lists[i+1] = mergeList(lists[i],lists[i+1]);
        }
        return lists[lists.length-1];
    }
    public ListNode mergeList(ListNode head1,ListNode head2){
        ListNode newH = new ListNode();
        ListNode cur = newH;
        while(head1!=null&&head2!=null){
            if(head1.val<head2.val){
                cur.next = head1;
                cur = head1;
                head1 = head1.next;
            }else{
                cur.next = head2;
                cur = head2;
                head2 = head2.next;
            }
        }
        while(head1!=null){
            cur.next = head1;
            cur = head1;
            head1 = head1.next;
        }
        while(head2!=null){
            cur.next = head2;
            cur = head2;
            head2 = head2.next;
        }
        return newH.next;
    }
```

# 35 接雨水问题

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

解法：先从两边(index1,index2)选取一个小(假设index1)的边(min)，然后从index1开始循环，循环条件是index1<index2并且height[i]<=index1，此时结果res+=min-height[index1++];反之一样。

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211111103527021.png" alt="image-20211111103527021" style="zoom:70%;" />

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

```java
public int trap(int[] height) {
        int index1 = 0;int index2 = height.length-1;
        int res = 0;
        while(index1<index2){
            int min = height[index1]<height[index2] ? height[index1]:height[index2];
            while(index1<index2&&height[index1]<=min){
                res += min-height[index1++];
            }
            while(index1<index2&&height[index2]<=min){
                res += min-height[index2--];
            }
        }
        return res;
    }
```

# 36 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

递归解法：

```java
List<Integer> res = new ArrayList();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null)return res;
        returns(root);
        return res;
    }
    private void returns(TreeNode root){
        if(root==null)return;
        returns(root.left);
        res.add(root.val);
        returns(root.right);
    }
```

# 37 *最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

解法1时间复杂度（O(N²)）：

![img](https://img2018.cnblogs.com/blog/1566782/201907/1566782-20190720102801874-648392881.gif)

```java
public int lengthOfLIS(int[] nums) {
        int[] len = new int[nums.length];
        Arrays.fill(len,1);
        for(int i=0;i<nums.length;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    len[i]=Math.max(len[i],len[j]+1);
                }
            }
        }
        int res = 0;
        for(int i=0;i<nums.length;i++){
            res = Math.max(res,len[i]);
        }
        return res;
    }
```

**解法2时间复杂度（O(Nlog(N))）**:

```java
public static int lengthOfLIS(int[] nums) {
        int[] temp = new int[nums.length];
        temp[0] = nums[0];
        int len = 1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>temp[len-1]){
                temp[len++] = nums[i];
            }else{
                int left = 0;int right = len-1;int mid = 0;
                while(left<right){
                    mid = (left+right)>>1;
                    if(temp[mid]==nums[i]){
                        left=mid;break;
                    }
                    else if(temp[mid]<nums[i])left = mid+1;
                    else right = mid;
                }
                temp[left] = nums[i];
            }
        }
        return len;
    }
```

# 38 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211116094032232.png" alt="image-20211116094032232" style="zoom:80%;" />

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

```java
public void reorderList(ListNode head) {
        int len = 0;
        ListNode temp = head;ListNode temp1 = head;
        //计算环的长度
        while(temp!=null){
            len++;temp = temp.next;
        }
        //将需要重排的结点找到，放入栈中
        Stack<ListNode> stack = new Stack();
        ListNode cur = head;
        for(int i=0;i<len;i++){
            if(i>=len/2+1){
                stack.push(cur);
            }
            cur = cur.next;
        }
        //重排
        for(int i=0;i<(len-1)>>1;i++){
            ListNode last = stack.pop();
            ListNode t = head.next;
            head.next = last;
            last.next = t;
            head = t;
        }
        //消除环
        for(int i=1;i<len;i++){
            temp1 = temp1.next;
        }
        temp1.next = null;
    }
```

# 39 二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211116095924399.png" alt="image-20211116095924399" style="zoom:70%;" />

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**解法：根据层序遍历思路来修改**

```java
public List<Integer> rightSideView(TreeNode root) {
        Queue<TreeNode> que = new LinkedList();
        List<Integer> res = new ArrayList();
        List<Integer> temp = new ArrayList();
        if(root==null)return res;
        que.add(root);
        while(!que.isEmpty()){
            int size = que.size();
            int sizes = size;
            while(size>0){
                TreeNode cur = que.poll();
                if(size==sizes){
                    res.add(cur.val);
                }
                if(cur.right!=null)que.add(cur.right);
                if(cur.left!=null)que.add(cur.left);
                size--;
            }
        }
        return res;
    }
```

# 40 爬楼梯

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

贪心策略：1阶是1种，2阶是2种，3阶是3种，4阶5种...

状态转移方程为：f(n) = f(n-1)+f(n-2)

```java
public int climbStairs(int n) {
        if(n==1)return 1;
        if(n==2)return 2;
        int x1 = 1;int x2 = 2;int index=3;
        while(index<=n){
            if(index%2==1)x1 = x1+x2;
            else x2 = x1+x2;
            index++;
        }
        return Math.max(x1,x2);
    }
```

非递归：时间复杂度O(N)；递归：时间复杂度O(N²)

# 41 链表中倒数第K个结点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

```java
public ListNode getKthFromEnd(ListNode head, int k) {
        if(head==null)return head;
        int len = 0;ListNode temp = head;
        while(temp!=null){
            len++;
            temp = temp.next;
        }
        for(int i=0;i<len-k;i++){
            head = head.next;
        }
        return head;
    }
```

# 42 *二叉树中最大路径和

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其最大路径和。

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

设一个全局变量（res）来记录各个路径和的最大值，每个结点返回（a+b,a+c,a）的最大值(temp)。更新res的值（max(res,max(temp,a+b+c))）。

```JAVA
	int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        sum(root);
        return res;
    }
    public int sum(TreeNode node){
        if(node==null)return 0;
        int sum1 = sum(node.left);
        int sum2 = sum(node.right);
        //(a+b,a+c,a)的最大值(temp)
        int temp = Math.max(node.val,node.val+Math.max(sum1,sum2));
        //更新res的值(max(res,max(temp,a+b+c)))
        res = Math.max(res,Math.max(temp,node.val+sum1+sum2));
        return temp;
    }
```

# 43 删除链表倒数第K个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
	if(n==0)return head;
    ListNode temp = head;int len = 0;
    while(temp!=null){
        len++;
        temp = temp.next;
    }
    //如果n==len，直接返回head.next
    if(len==n)return head.next;
    ListNode cur = head;
    for(int i=1;i<len-n;i++){
        cur = cur.next;
    }
    ListNode temp1 = cur.next.next;
    cur.next = temp1;
    return head;
}
```

# 44 *x的平方根

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去** 。

```
输入：x = 4
输出：2
```

```java
public int mySqrt(int x) {
        if(x<=0)return 0;
        int mid=0;int l = 1;int r = x;
        while(true){
            mid = (l+r)>>1;
            if(mid<=x/mid&&(mid+1)>x/(mid+1)){
                return mid;
            }else if(mid<x/mid){
                l = mid+1;
            }else r = mid-1;
        }
    }
```

# 45 字符串转换成整数

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。

```
示例 1：
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。

示例 2：
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。

示例 3：
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。

示例 4：
输入：s = "words and 987"
输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。

示例 5：
输入：s = "-91283472332"
输出：-2147483648
解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。
```

```java
public static int myAtoi(String s) {
        if(s.equals(""))return 0;
        StringBuilder sb = new StringBuilder();
        int index=0;
        while(s.charAt(index)==' '){
            index++;
            if(index==s.length())return 0;
        }
        if(s.charAt(index)=='-'||s.charAt(index)=='+'){
            sb.append(s.charAt(index++));
        }
        for(int i=index;i<s.length();i++){
            int cur = s.charAt(i)-'0';
            if(cur>=0&&cur<=9){
                sb.append(cur);
            }else{
                break;
            }
        }
        if(sb.length()==0||(sb.length()==1&&(sb.charAt(0)=='+'||sb.charAt(0)=='-')))return 0;
        String temps = null;
        int index1 = 0;int index2 = 0;
        if(sb.charAt(0)=='+'||sb.charAt(0)=='-'){
            index1 = 1;index2 = index1;
        }
        while(sb.charAt(index2)=='0'&&index2<sb.length()-1){
            index2++;
        }
        sb.delete(index1,index2);
        if(sb.length()==0||(sb.length()==1&&(sb.charAt(0)=='+'||sb.charAt(0)=='-')))return 0;
        if(sb.length()>13)temps = sb.substring(0,13);
        else temps = sb.toString();
        long temp = Long.parseLong(temps);
        if(temp<=-2147483648){
            return -2147483648;
        }else if(temp>=2147483647)return 2147483647;
        else return (int)temp;
    }
```

# 46 删除链表中重复的元素Ⅱ

存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 **没有重复出现** 的数字.

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211121154207490.png" alt="image-20211121154207490" style="zoom:70%;" />

<img src="C:\Users\wangxue\AppData\Roaming\Typora\typora-user-images\image-20211121200036955.png" alt="image-20211121200036955" style="zoom:60%;" />

```java
public ListNode deleteDuplicates(ListNode head) {
        if(head==null||head.next==null)return head;
        ListNode res = new ListNode(0,head);ListNode cur = res;
        //循环条件
        while(cur.next!=null&&cur.next.next!=null){
            //若cur.next的值等于cur.next.next的值，记录此值进行比较。
            if(cur.next.val==cur.next.next.val){
                int x = cur.next.val;
                while(cur.next!=null&&cur.next.val==x){
                    cur.next = cur.next.next;
                }
            }else{
                cur = cur.next;
            }
        }
        return res.next;
    }
```

# 47 两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null)return l2;
        if(l2==null)return l1;
        int x = (l1.val+l2.val)%10;
        int next = (l1.val+l2.val)/10;
        ListNode res = new ListNode(x);
        ListNode cur = res;
        l1 = l1.next;l2 = l2.next;
        while(l1!=null&&l2!=null){
            x = (l1.val+l2.val+next)%10;
            next = (l1.val+l2.val+next)/10;
            ListNode temp = new ListNode(x);
            cur.next = temp;
            cur = temp;
            l1 = l1.next;l2 = l2.next;
        }
        while(l1!=null){
            x = (l1.val+next)%10;
            next = (l1.val+next)/10;
            ListNode temp = new ListNode(x);
            cur.next = temp;
            cur = temp;l1 = l1.next;
        }
        while(l2!=null){
            x = (l2.val+next)%10;
            next = (l2.val+next)/10;
            ListNode temp = new ListNode(x);
            cur.next = temp;
            cur = temp;
            l2 = l2.next;
        }
        if(next!=0){
            ListNode temp = new ListNode(next);
            cur.next = temp;
        }
        return res;
    }
```

# 48 二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

递归：

```java
public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList();
        if(root==null)return res;
        itera(root,res);
        return res;
    }
    public void itera(TreeNode root,List<Integer> list){
        if(root==null)return ;
        list.add(root.val);
        itera(root.left,list);
        itera(root.right,list);
    }
```

# 49 *编辑距离（一个字符串变成另一个字符串的最小操作数）

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：插入一个字符；删除一个字符；替换一个字符

解法：状态转移方程：

若word1和word2的最后一个元素不同：ress [i] [j] = Math.min(left+1,up+1,up_left+1);

若相同：ress [i] [j] = Math.min(left+1,up+1,up_left);

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

```java
public int minDistance(String word1, String word2) {
        int n = word1.length();int m = word2.length();
        int[][] ress = new int[n+1][m+1];
        if(n*m==0)return Math.max(n,m);
        //初始化ress数组,即变为空数组需要进行的操作
        for(int i=0;i<n+1;i++){
            ress[i][0] = i;
        }
        for(int i=0;i<m+1;i++){
            ress[0][i] = i;
        }
        for(int i=1;i<=n;i++){
            char temp1 = word1.charAt(i-1);
            for(int j=1;j<=m;j++){
                char temp2 = word2.charAt(j-1);
                int left = ress[i][j-1]+1;
                int up = ress[i-1][j]+1;
                int up_left = ress[i-1][j-1];
                if(temp1!=temp2){
                    up_left++;
                }
                ress[i][j] = Math.min(left,Math.min(up_left,up));
            }
        }
        return ress[n][m];
    }
```

# 50 *排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表**。

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

归并排序

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null)return head;
        return sort(head,null);
    }
    public ListNode sort(ListNode head,ListNode tail){
        //递归结束条件，当head.next等于结尾时，令head.next为空，返回head
        if(head.next==tail){
            head.next = null;
            return head;
        }
        ListNode slow = head,fast = head;
        while(fast!=tail&&fast.next!=tail){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode node1 = sort(head,slow);
        ListNode node2 = sort(slow,tail);
        return mergesort(node1,node2);
    } 
    public ListNode mergesort(ListNode head1,ListNode head2){
        ListNode head = new ListNode(0);
        ListNode cur = head;
        while(head1!=null&&head2!=null){
            if(head1.val<head2.val){
                cur.next = head1;
                head1 = head1.next;
            }else{
                cur.next = head2;
                head2 = head2.next;
            }
            cur = cur.next;
        }
        while(head1!=null){
            cur.next = head1;
            cur = cur.next;
            head1 = head1.next;
        }
        while(head2!=null){
            cur.next = head2;
            cur = cur.next;
            head2 = head2.next;
        }
        return head.next;
    }
}
```

# 51	平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

```java
public boolean isBalanced(TreeNode root) {
        if(root==null)return true;
        if(isBalanced(root.left)&&isBalanced(root.right)){
            return Math.abs(heigh(root.left)-heigh(root.right))<=1;
        }else{
            return false;
        }
    }
    public int heigh(TreeNode root){
        if(root==null)return 0;
        int h1 = heigh(root.left);
        int h2 = heigh(root.right);
        return Math.max(h1,h2)+1;
    }
```

# 52	*下一个排列

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

解法：

首先从后向前查找**第一个**顺序对 (i,i+1)，**满足 a[i] < a[i+1]**。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找**第一个元素 j 满足 a[i] < a[j]**。这样「较大数」即为 a[j]。

交换 a[i]与 a[j]，此时可以证明区间[i+1,n) 必为降序。我们可以直接使用双指针反转区间[i+1,n) 使其变为升序，而无需对该区间进行排序。

<img src="https://assets.leetcode-cn.com/solution-static/31/31.gif" alt="fig1" style="zoom:67%;" />

```java
public void nextPermutation(int[] nums) {
        if(nums.length==0||nums.length==1)return;
        int index1 = nums.length-1;
        int index2 = nums.length-1;
        while(index1>0){
            if(nums[index1]<=nums[index1-1]){
                index1--;
            }else{
                index1--;
                break;
            }
        }
        while(index2>0){
            if(nums[index1]<nums[index2]){
                break; 
            }else{
                index2--;
            }
        }
        if(index1==index2){
            Arrays.sort(nums);
            return;
        }
        swap(index1,index2,nums);
        Arrays.sort(nums,index1+1,nums.length);
    }
    public void swap(int index1,int index2,int[] nums){
        int c = nums[index2];
        nums[index2] = nums[index1];
        nums[index1] = c;
    }
```

# 53	二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

```
	3
   / \
  9  20
    /  \
   15   7
```

```java
public int maxDepth(TreeNode root) {
        if(root==null)return 0;
        int h1=maxDepth(root.left);
        int h2=maxDepth(root.right);
        return Math.max(h1,h2)+1;
    }
```

# 54	*最小覆盖子串(滑动窗口)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""`。

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

```java
public String minWindow(String s, String t) {
        if(t.length()>s.length())return "";
        int[] must = new int[128];
        int[] temp = new int[128];
        for(int i=0;i<t.length();i++){
            must[t.charAt(i)]++;
        }
        int left=0,right=0,start=0,count=0;int min = Integer.MAX_VALUE;
        while(right<s.length()){
            char cur = s.charAt(right);
            if(must[cur]==0){
                right++;continue;
            }
            if(temp[cur]<must[cur]){
                count++;
            }
            temp[cur]++;
            right++;
            while(count==t.length()){
                if(right-left<min){
                    min = right-left;
                    start = left;
                }
                char cur1 = s.charAt(left);
                if(must[cur1]==0){
                    left++;
                    continue;
                }
                if(temp[cur1]==must[cur1]){
                    count--;
                }
                temp[cur1]--;
                left++;
            }
        } 
        return min==Integer.MAX_VALUE ? "":s.substring(start,start+min);
    }
```

# 55	翻转字符里的单词

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

```
输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"
```

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        int len = s.length();
        StringBuilder res = new StringBuilder();int index=0;
        for(int i=len-1;i>=0;i--){
            index = i;
            while(i>=0&&s.charAt(i)!=' '){
                i--;
            }
            if(i>0&&index!=i)res.append(s.substring(i+1,index+1)+" ");
            else res.append(s.substring(i+1,index+1));
        }
        return res.toString();
    }
}
```

# 56	从前序和中序遍历序列构造二叉树

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) { 
        return treeRes(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }
    public TreeNode treeRes(int[] preorder,int prel,int prer,int[] inorder,int inl,int inr){
        if(prel>prer||inl>inr)return null;
        int cur = preorder[prel];
        TreeNode curNode = new TreeNode(cur);
        int temp = inl;
        while(inorder[temp]!=cur)temp++;
        //注意temp不是左子树数组的长度，而是inl+长度
        curNode.left = treeRes(preorder,prel+1,prel+temp-inl,inorder,inl,temp);
        curNode.right = treeRes(preorder,prel+temp-inl+1,prer,inorder,temp+1,inr);
        return curNode;
    }
}
```

# 57	从中序和后续遍历序列构造二叉树

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return treeRes(inorder,0,inorder.length-1,postorder,0,postorder.length-1);
    }
    public TreeNode treeRes(int[] inorder,int inl,int inr,int[] postorder,int posl,int posr){
        if(inl>inr||posl>posr)return null;
        int cur = postorder[posr];
        TreeNode curNode = new TreeNode(cur);
        int temp = inl;
        while(inorder[temp]!=cur)temp++;
        curNode.right = treeRes(inorder,temp+1,inr,postorder,posl+temp-inl,posr-1);
        curNode.left = treeRes(inorder,inl,temp-1,postorder,posl,posl+temp-inl-1);
        return curNode;
    }
}
```

# 58	寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数**。

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len1 = nums1.length,index1 = 0;
        int len2 = nums2.length,index2 = 0;
        if(len1==0&&len2==0)return 0;
        if(len1==0)return len2%2==1 ? (double)nums2[len2/2]:(double)(nums2[len2/2]+nums2[len2/2-1])/2;
        if(len2==0)return len1%2==1 ? (double)nums1[len1/2]:(double)(nums1[len1/2]+nums1[len1/2-1])/2;
        int len = len1+len2;
        int[] help = new int[len];int index=0;
        while(index1<len1&&index2<len2){
            help[index++] = nums1[index1]<nums2[index2] ? nums1[index1++]:nums2[index2++];
        }
        while(index1<len1){
            help[index++] = nums1[index1++];
        }
        while(index2<len2){
            help[index++] = nums2[index2++];
        }
        return len%2==1 ? (double)help[len/2]:(double)(help[len/2]+help[len/2-1])/2;
    }
}
```

# 59	*滑动窗口最大值（滑动窗口）

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] res = new int[nums.length-k+1];
        Deque<Integer> que = new LinkedList();
        for(int i=0;i<k;i++){
            while(!que.isEmpty()&&nums[i]>=nums[que.peekLast()]){
                que.pollLast();
            }
            que.addLast(i);
        }
        res[0] = nums[que.peekFirst()];
        for(int i=k;i<nums.length;i++){
            while(!que.isEmpty()&&nums[i]>=nums[que.peekLast()]){
                que.pollLast();
            }
            que.addLast(i);
            if(que.peekFirst()<=i-k){
                que.pollFirst();
            }
            res[i-k+1] = nums[que.peekFirst()];
        }
        return res;
    }
}
```

# 60	最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int res = Integer.MAX_VALUE,dif = Integer.MAX_VALUE;
        Arrays.sort(nums);
        for(int i=0;i<nums.length-2;i++){
            int last = nums.length-1;
            for(int j=i+1;j<nums.length-1;j++){
                int temp = 0;
                while(last>j){
                    temp = nums[i]+nums[j]+nums[last];
                    if(Math.abs(target-temp)<dif){
                        dif = Math.abs(target-temp);
                        res = temp;
                    }
                    if(temp-target<0)break;
                    last--;
                }
            }
        }
        return res;
    }
}
```

# 61	复原IP

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

